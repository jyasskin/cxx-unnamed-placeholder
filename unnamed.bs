<pre class='metadata'>
Title: A placeholder with no name
Shortname: D????
Revision: 0
Audience: EWG
Status: D
Group: WG21
URL: http://wg21.link/D????r0
!Source: <a href="https://github.com/jyasskin/cxx-unnamed-placeholder/blob/master/unnamed.bs">https://github.com/jyasskin/cxx-unnamed-placeholder/blob/master/unnamed.bs</a>
Editor: Jeffrey Yasskin, Google, jyasskin@google.com
Editor: JF Bastien, Apple, jfbastien@apple.com
Abstract: A C++ token for deduced locations that says not to name whatever was deduced.
Date: 2018-06-07
Markup Shorthands: markdown yes
Complain About: missing-example-ids yes
</pre>

> ‚ùùI've been through the compiler on a var with no name<br>
> It felt good to be out of `main`<br>
> In the compiler you can remember your name<br>
> 'Cause there ain't no diagnostic for to give you no pain‚ùû
>
> ‚Äî A Var with no Name

# Introduction and motivation # {#intro}

We have several locations in C++ where a name is expected, but programmers may
not need to use that name ever again. Right now, they have to pick a different
name for each location, and readers can't immediately tell that the name isn't
used without an attribute or a naming convention. It would be nice to have a
clear, enforceable way to state that a name is ignored.

To enforce that the name is actually ignored, and that people reading the code
don't think that an unused variable is actually used, using it in an expression
should be an error instead of having a tag type like `nullptr_t`.

One of the authors of this paper filed [[EWG35]] on this subject years ago and
then forgot about it. Unlike that issue, this paper does not expect the
semantics of the placeholder name to be defined in terms of a generated unique
name.

# Examples # {#examples}

The goal of this section is to provide an example of using the placeholder in
all declaration contexts where it makes sense. These examples use `__` as the
placeholder, but see [[#spelling]] for an analysis of several options.

## Variables ## {#ex-variables}

To lock a mutex for a scope, without worrying that the variable name is already
taken:

```c++
std::lock_guard<std::mutex> __(a_mutex);
std::lock_guard<std::mutex> __(a_second_mutex);
```

To hold some data alive that's used via internal pointers:

```c++
std::unique_ptr<T> ptr = ...;
auto& field1 = ptr->field1;
auto& field2 = ptr->field2
[__=std::move(ptr), &field1=field1, &field2=field2](){...};
```

Note that the lambda capture case syntactically allows `[&__=init, ...](){}`, but
this is probably not useful.

Classes can also have data members named `__`, which have the marginal use of
reserving space for the future addition of new ABI-compatible fields. These
fields cannot be used for the same purpose as in lambda captures because they
can't be initialized.

```c++
class Foo {
  Foo(std::unique_ptr<T> ptr)
    : __(std::move(ptr)) // Doesn't work.
    {}

  std::unique_ptr<T> __; // Not effective.
  int32_t __[4]; // Reserve 4 words of space for future fields.
};
```

## Structured Bindings ## {#ex-structured-binding}

[[P0144R2]] ¬ß3.8 mentions that structured bindings could potentially use a
syntax to ignore some fields from a bound structure:

> ```c++
> tuple<T1,T2,T3> f();
> auto [x, std::ignore, z] = f(); // NOT proposed: ignore second element
> ```

[[P0144R2]] suggests waiting until a pattern matching proposal, at which point
the right token will fall out. I suggest that this proposal also provides a
reasonable token, making this:

```c++
tuple<T1,T2,T3> f();
auto [x, __, z] = f(); // Ignore second element.
```

## Enumerators ## {#ex-enumerator}

This makes it very slightly easier to skip a value:

```c++
enum MmapBits {
  Shared,
  Private,
  __,
  __,
  Fixed,
  Rename,
  ...
};
```

I suspect that this is less clear than explicitly assigning the values, so it
would make sense to not support this.

## Speculative: Concept-constrained declarations ## {#ex-concept}

To define a deduced-type non-type template parameter where the type matches a
concept but the type isn't given a name in the body of the class or function:

```c++
template<Integral __ N> class integral_constant { ... };
```

To declare a deduced-type parameter or local variable whose type is constrained
by a concept:

```c++
Numeric multiplyAdd(Numeric __ x, Numeric __ y, Numeric __ z) {
  Numeric __ multiplied = x * y;
  return multiplied + z;
}
```

## Less useful examples ## {#less-useful-ex}

### Class, Struct, Enum ### {#ex-class}

These aren't necessary because developers can simply omit the name, but might
still be useful to simplify the declaration syntax:

```c++
class __ : Base { ... };
struct __ : Base { ... };
enum __ { Enumerator };
```

We couldn't actually require a name there for several more versions of C++, if
ever, but local style guides could require it in order to simplify what they
need to teach new C++ developers.

### Unnamed parameters ### {#ex-unnamed-param}

Like unused class names, parameter names can simply be omitted instead of
needing a placeholder. Again, requiring an explicitly-unused name, instead of
allowing it to be omitted, simplifies the declaration grammar.

```c++
class C : public Base {
  void Func(int i, long __) override;
};

template<typename __>
class UsedInTemplateTemplateParam { ... };
```

### Function names ### {#ex-function}

Using `__` to name a function is a similar case to declaring a variable, except
that function definitions don't have the kind of side-effects that variable
definitions have.

```c++
void __(int arg) { ... }
void __(long arg) { ... }
```

Since the use of `__` prevents code from referring to these functions after
they're declared, the above code creates two independent functions rather than
an overload set (although I can't think of a way to distinguish the two).

Virtual functions can also be named `__`. Having an unnamed virtual function
take up a vtable slot could be useful to preserve ABI compatibility when a
future function is added, but that's a matter for platform ABIs rather than the
standard. This kind of virtual function cannot be overridden, of course, since
it can't be named again after its declaration.

### Using ### {#ex-using}

To use a type name, without being able to use the alias. I don't think using a
type name has side-effects, so there's probably not much point.

```c++
using __ = typename Base::value_type;
```

Similarly non-useful:

```c++
typedef typename Base::value_type __;
namespace __ = std::ranges;
```

### Concept introduction ### {#ex-concept-intro}

Like name aliases, a `requires` clause doesn't have side-effects, so doesn't
need to be assigned to an unnamed concept.

```c++
concept __ = requires {...};
```

## Discouraged examples ## {#discouraged-ex}

### Anonymous Namespaces ### {#ex-anon-namespace}

It would be possible to use `__` as the name of an unnamed namespace:

```c++
namespace __ { ... };
```

However, the meaning of an anonymous namespace isn't just the meaning of a
namespace with a name you never use again. Instead, [**namespace.unnamed**]
says,

> An *unnamed-namespace-definition* behaves as if it were replaced by
>
> <pre>inline<sub><i>opt</i></sub> namespace <i>unique</i> { /* empty body */ }
> using namespace <i>unique</i> ;
> namespace <i>unique</i> { <i>namespace-body</i> }</pre>

Because of this divergence in meaning from the other places `__` can appear, I
recommend disallowing it as a namespace name.

# Prior Art # {#prior}

## Haskell ## {#prior-haskell}

Haskell uses a `_` token to indicate unused things:

```haskell
head (x:_)  = x
tail (_:xs) = xs
```

Note that the _ can be "initialized" multiple times, unlike a named but unused
variable:

```haskell
data Colour = Colour { red::Int, green::Int, blue::Int, opacity::Int}

isOpaqueColour :: Colour -> Bool
isOpaqueColour (Colour _ _ _ opacity) = opacity == 255
```

## Python ## {#prior-python}
TODO

## Scala ## {#prior-scala}
TODO

## Rust ## {#prior-rust}
TODO

## Swift ## {#prior-swift}
TODO

## C#  ## {#prior-csharp}
TODO

> We are also encouraged to use _ as the discard character instead of *. It works better visually, and is what many other languages already use.
>
> There is a small matter of _ already being a valid identifier. In order for it to coexist as a discard with existing valid uses we need to use a few tricks.
>
> ‚Äî[dotnet/roslyn#16674](https://github.com/dotnet/roslyn/issues/16674)

## Erlang ## {#prior-erlang}
TODO

## Elixir ## {#prior-elixir}
TODO

## Prolog ## {#prior-prolog}
TODO

## OCaml ## {#prior-ocaml}
TODO

## F# ## {#prior-fsharp}
TODO

## Java ## {#prior-java}

Java uses a `?` token to represent a "wildcard" generic argument.

```java
void printCollection(Collection<?> c) {
    for (Object e : c) {
        System.out.println(e);
    }
}
```

Java generic arguments usually need to be declared, but wildcards imply that a
function is generic:

```java
class Collections {
    public static <T, S extends T> void copy(List<T> dest, List<S> src) {
    ...
}

class Collections {
    public static <T> void copy(List<T> dest, List<? extends T> src) {
    ...
}
```

## Googlemock ## {#prior-googlemock}

Googlemock defines
[`_`](https://github.com/google/googletest/blob/master/googlemock/docs/CheatSheet.md#wildcard)
to match anything. It doesn't use it for declarations, but it's still an "ignore
this" token.

```c++
// Expects the turtle to move forward by 100 units.
EXPECT_CALL(turtle, Forward(100));

// Expects the turtle to move forward.
EXPECT_CALL(turtle, Forward(_));
```

## Halide ## {#prior-halide}

From Halide's
[documentation](http://halide-lang.org/docs/class_halide_1_1_var.html#a333e72cf9af6339530cb3544b7fe1324):

> For example, consider the definition:
>
> ```c++
> Func f, g;
> Var x, y;
> f(x, y) = 3;
> ```
>
> A call to f with the placeholder symbol _ will have implicit arguments injected automatically, so f(2, _) is equivalent to f(2, _0), where _0 = Var::implicit(0), and f(_) (and indeed f when cast to an Expr) is equivalent to f(_0, _1). The following definitions are all equivalent, differing only in the variable names.
>
> ```c++
> g(_) = f*3;
> g(_) = f(_)*3;
> g(x, _) = f(x, _)*3;
> g(x, y) = f(x, y)*3;
> ```

# Spelling # {#spelling}

How should we spell the token?

## `_` ## {#spell-underscore}

I believe `_` is the ideal spelling, but [**lex.name**] ¬∂3.2 only reserves it in
the global namespace, and it's now used by libraries:

* [`testing::_` in
    Googlemock](https://github.com/google/googletest/blob/master/googlemock/docs/CheatSheet.md#wildcard)
* [`Halide::_` in Halide](http://halide-lang.org/docs/_var_8h.html)
* [The `_()` macro in Gnu
    Gettext](https://www.gnu.org/software/gettext/manual/html_node/Mark-Keywords.html)

To avoid making these existing uses of `_` ill-formed, see [[#qs-second-use]].

## `__` ## {#spell-double-under}

This is already a reserved identifier per [**lex.name**] ¬∂3.1.

> Each identifier that contains a double underscore `__` or begins with an
> underscore followed by an uppercase letter is reserved to the implementation
> for any use.

It takes a little longer to type than `_`, and in many fonts the difference
between `__` and `_` may be unclear.

This paper uses `__` in the [examples](#examples).

The `__` identifier is used in some codebases, such as [the V8 JavaScript
engine](https://github.com/v8/v8/search?q=%22define+__%22&unscoped_q=%22define+__%22_).
Using a macro named `__` as V8 does means that breakage will only occur if that
codebase also attempts to use this new feature.

## `?` ## {#spell-question}

`?` might be confusable with the ternary `?:` operator, but developers can
distinguish based on it appearing in a declaration rather than expression
context.

`?` may also be confused with a wildcard like `*`, to mean "union all the
possible values in this position", for example in a `nested::name::specifier`.
Fortunately, I don't see a reason for `?` to be valid in contexts where that
interpretation is plausible.

Using `?` for the placeholder identifier might prevent its use in the syntax for
a forwarding reference. e.g. `ForwardingRef&&?`.

## Repeated `?` ## {#spell-rep-question}

Multiple `?` could be used to disambiguate some of the issues with a single `?`.
Using `??` or `???` is more typing but is fairly obvious, though it would likely
be better to make this a token so whitespace cannot be used between question marks.

## `auto` ## {#spell-auto}

The "attribute" proposal for concept declarations uses `auto` in a place a type
might appear, which one might consider precedent for using it as a more general
placeholder.

## Omit the name ## {#spell-omit}

We could just allow omitted names in more places:

```c++
auto = std::lock_guard(mx);
```

This option ¬´mov[es] closer to "all syntax is valid and means something, but
maybe not what you meant".¬ª ‚Äî [Tony Van
Eerd](http://lists.isocpp.org/ext/2018/06/4518.php)

## Various Unicode characters ## {#üí©}

We could use various Unicode characters, such as the replacement character
`ÔøΩ`, the empty set `‚àÖ`, the interrobang `‚ÄΩ`, a trash can `üóë`, one of the
recycle signs `‚ôªÔ∏è`, and countless other characters.
These all have the shortcoming that not all toolchains and editors support
them well or uniformly.

# Semantic questions # {#semantic-qs}

## Only on second use ## {#qs-second-use}

We could declare that our placeholder makes variables anonymous only once it's
used for the second time in a scope. That is:

```c++
int _ = 10; // fine
_ = 11; // fine, can use it
int _ = 12; // another _, fine
// at this point, both _ variables exist, but can no longer be accessed:
_ = 13; // error - which one?
```

Within this option, we could decide whether or not a second declaration is
ill-formed if `_` has already been used within the scope.

Allowing this option at namespace scope, as [Googlemock](#prior-googlemock)
would need, seems to make ODR violations more likely. A file with only 1 unused
variable (perhaps used to register a static initializer) would be likely to
forget that variable's `static` and so generate an external symbol, which would
collide with a similar symbol from another file.

# Wording # {#wording}

TBD

# Acknowledgements # {#ack}

Thanks to:

* Daveed Vandevoorde for suggesting using `?`.
* Thomas K√∂ppe for suggesting `auto`.
* Mathias Stearn for suggesting omitting the name.
* Tony Van Eerd for providing an argument against omitting the name, and for
    suggesting that `_` only become magic when it's re-used.
* Richard Smith for pointing out Halide.
* Michael Park for a long list of languages that use `_`.
